

spring:
#  zipkin:
#    rabbitmq:
#      queue: zipkin
  sleuth:
    sampler:
      percentage: 0.2

zuul:
  ribbon:
    eager-load:
      enabled: true
      clients: mcp-auth,mcp-upms-service
  ignoredServices: '*'
  host:
    connect-timeout-millis: 30000
    socket-timeout-millis: 30000
  routes:
    mcp-auth:
      path: /auth/**
      serviceId: mcp-auth
      stripPrefix: true
      sensitiveHeaders:
    mcp-upms-service:
      path: /admin/**
      serviceId: mcp-upms-service
      stripPrefix: true
      sensitiveHeaders:
  ratelimit:
    key-prefix: mcp-ratelimite
    enabled: true
    repository: REDIS
    behind-proxy: true
    policies:
      mcp-upms-service:
        limit: 100
        quota: 100
        refresh-interval: 3

security:
  validate:
    code: true
    preview: true
  sessions: stateless
  oauth2:
    client:
      client-id: mcp
      client-secret: mcp
    resource:
      loadBalanced: true
      token-info-uri: ${security.auth.server}/oauth/check-token
      service-id: mcp-gateway
      jwt:
         key-uri: ${security.auth.server}/oauth/token_key #解析jwt令牌所需要密钥的地址
#开启重试在某些情况下是有问题的，比如当压力过大，一个实例停止响应时
#，路由将流量转到另一个实例，很有可能导致最终所有的实例全被压垮。说到底，
#断路器的其中一个作用就是防止故障或者压力扩散。用了retry，断路器就只有在该服务的所有实例都无法运作的情况下才能起作用。这种时候，断路器的形式更像是提供一种友好的错误信息，或者假装服务正常运行的假象给使用者。
# 不用retry，仅使用负载均衡和熔断，就必须考虑到是否能够接受单个服务实例关闭和eureka刷新服务列表之间带来的短时间的熔断。如果可以接受，就无需使用retry。
#zuul:
#  retryable: true
#ribbon:
#   MaxAutoRetries: 2
#   MaxAutoRetriesNextServer: 0

urls:
  anon:
    - /mobile/**
    - /auth/**
    - /admin/code/*
    - /admin/smsCode/*
    - /admin/user/info
    - /admin/menu/userTree
    - /swagger-resources/**
    - /swagger-ui.html
    - /*/v2/api-docs
    - /swagger/api-docs
    - /webjars/**